/*
  Projeto: Escalonamento RM ↔ EDF no ESP32
  Autor: Gabriella Arévalo e Hebert Alan Kubis
  Matéria: Sistemas de Tempo Real 2025.2
  
  Funcionalidades (o que eu tentei fazer né):
  - 3 tarefas periódicas com medições reais
  - 1 tarefa aperiódica acionada por botão (ISR)
  - Alternância dinâmica entre RM e EDF via Serial ("RM" ou "EDF")
  - Medição de:
      * tempo de CPU (execução)
      * jitter
      * ativação real vs período
      * deadline miss
      * utilização total U
  - Logs detalhados com prioridade atual

OBS: peguei o code do RM_Ap e implementei o EDF e pedi pro chat juntar as coisas do diplay/web que voçê fez no code RM_EDF
*/

#include <WiFi.h>
#include <WebServer.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <LiquidCrystal.h>

// -------------------- LCD --------------------
const int rs = 5; 
const int en = 4;
const int d4 = 18;
const int d5 = 19;
const int d6 = 23;
const int d7 = 27;

LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

byte barra_1_linha[]  = {B10000,B10000,B10000,B10000,B10000,B10000,B10000,B10000};
byte barra_2_linhas[] = {B11000,B11000,B11000,B11000,B11000,B11000,B11000,B11000};
byte barra_3_linhas[] = {B11100,B11100,B11100,B11100,B11100,B11100,B11100,B11100};
byte barra_4_linhas[] = {B11110,B11110,B11110,B11110,B11110,B11110,B11110,B11110};

// -------------------- WIFI --------------------
const char* ssid     = "TrabalhoSTR";
const char* password = "123456789";
WebServer server(80);

// -------------------- Scheduler --------------------
volatile char currentScheduler[4] = "RM"; // "RM" ou "EDF"
static SemaphoreHandle_t mtxSheduler;

#define NUM_TASKS 3   // agora temos 3 periódicas

typedef struct {
    const char *name;
    uint32_t periodo_ms;
    uint32_t carga_us;
    int pin;
    UBaseType_t prioridade_rm;  // prioridade fixa usada no RM
    uint64_t total_exec_us;
    uint32_t ativacoes;
    uint32_t misses;

    // -------- EDF --------
    uint64_t next_deadline;
    TaskHandle_t handle;

} TarefaPeriodica;

// -----------------------------------------------------------
// TAREFAS PERIÓDICAS
// -----------------------------------------------------------
// 100ms - 200ms - 400ms
TarefaPeriodica tarefas[NUM_TASKS] = {
    {"Sensor", 100, 0, -1, 3, 0, 0, 0, 0, NULL},
    {"Media", 200, 0, -1, 2, 0, 0, 0, 0, NULL},
    {"Display", 400, 0, 26, 1, 0, 0, 0, 0, NULL}
};

static SemaphoreHandle_t mtxTasks;

// -------------------- LOAD SYSTEM --------------------
static int cpuLoad = 0;
static SemaphoreHandle_t mtxLoad;

// -------------------- Status LED --------------------
const int statusLedPin = 2;
bool ledEnabled = true;
bool IsStarted = true;

void setupPWM() {
    pinMode(statusLedPin, OUTPUT);
    digitalWrite(statusLedPin, HIGH);
}

// ========================================================
// Função que troca RM ↔ EDF 
// ========================================================
void setScheduler(String mode) {
    if (mode == "RM" || mode == "EDF") {
        xSemaphoreTake(mtxSheduler, portMAX_DELAY);
        strncpy((char*)currentScheduler, mode.c_str(), 3);
        xSemaphoreGive(mtxSheduler);

        if (mode == "RM") digitalWrite(statusLedPin, HIGH);
        else digitalWrite(statusLedPin, LOW);

        Serial.printf("MODO ALTERADO PARA: %s\n", mode.c_str());
    }
}

// ========================================================
//               APLICAÇÃO DO EDF DINÂMICO
// ========================================================
void aplicarEDF() {
    xSemaphoreTake(mtxTasks, portMAX_DELAY);

    // Ordenar tarefas por menor deadline
    for (int i = 0; i < NUM_TASKS - 1; i++) {
        for (int j = i + 1; j < NUM_TASKS; j++) {
            if (tarefas[j].next_deadline < tarefas[i].next_deadline) {
                TarefaPeriodica tmp = tarefas[i];
                tarefas[i] = tarefas[j];
                tarefas[j] = tmp;
            }
        }
    }

    // Aplicar prioridade dinâmica no FreeRTOS
    for (int i = 0; i < NUM_TASKS; i++) {
        UBaseType_t pr = (NUM_TASKS - i) + 1;
        vTaskPrioritySet(tarefas[i].handle, pr);
    }

    xSemaphoreGive(mtxTasks);
}

// ========================================================
//     Função genérica para toda tarefa periódica
// ========================================================
void tarefaPeriodica(void *pvParameters) {

    TarefaPeriodica *t = (TarefaPeriodica*) pvParameters;
    TickType_t ultimoTick = xTaskGetTickCount();
    TickType_t periodoTicks = pdMS_TO_TICKS(t->periodo_ms);

    for(;;) {

        vTaskDelayUntil(&ultimoTick, periodoTicks);

        uint64_t inicio = esp_timer_get_time();

        // ------- atualizar deadline (EDF) -------
        t->next_deadline = inicio + (t->periodo_ms * 1000ULL);

        // ------- aplicar EDF se ativo -------
        xSemaphoreTake(mtxSheduler, portMAX_DELAY);
        bool modoEDF = (strcmp((char*)currentScheduler, "EDF") == 0);
        xSemaphoreGive(mtxSheduler);
        if (modoEDF) aplicarEDF();

        // -------- a lógica de cada tarefa --------
        if (strcmp(t->name, "Sensor") == 0) {
            int leitura = analogRead(34);
            Serial.printf("[Sensor] Leitura: %d\n", leitura);
        }

        if (strcmp(t->name, "Media") == 0) {
            static int soma = 0, n = 0;
            soma += analogRead(34);
            n++;
            if (n >= 5) {
                int media = soma / n;
                Serial.printf("[MEDIA] = %d\n", media);
                soma = 0; n = 0;
            }
        }

        if (strcmp(t->name, "Display") == 0) {
            lcd.setCursor(0, 0);
            lcd.print("Modo: ");

            xSemaphoreTake(mtxSheduler, portMAX_DELAY);
            String mode = (const char*) currentScheduler;
            xSemaphoreGive(mtxSheduler);

            lcd.print(mode);
            for(int i=mode.length(); i<10; i++) lcd.print(" ");
        }

        // ----------- medir execução --------------
        uint64_t fim = esp_timer_get_time();
        uint64_t exec_us = fim - inicio;

        t->carga_us = exec_us;
        t->total_exec_us += exec_us;
        t->ativacoes++;

        if(exec_us > (t->periodo_ms * 1000ULL)){
            t->misses++;
            Serial.printf("[MISS] %s excedeu o período (%llu us)\n",
                          t->name, (unsigned long long)exec_us);
        }
    }
}

// ========================================================
// Página HTML (mesmo código seu)
// ========================================================
String htmlPage() {
    xSemaphoreTake(mtxSheduler, portMAX_DELAY);
    String currentModeString = (const char*)currentScheduler;
    xSemaphoreGive(mtxSheduler);

    String page = "<!DOCTYPE html><html><head><meta charset='utf-8'>";
    page += "<title>Controle RTOS</title>";
    page += "<style>body{background:#111;color:#eee;font-family:sans-serif;text-align:center;}";
    page += "button{padding:12px 25px;margin:10px;color:white;background:#444;border:none;}</style>";
    page += "</head><body>";

    page += "<h1>Modo RTOS: "+currentModeString+"</h1>";
    page += "<button onclick='setMode(\"RM\")'>RM</button>";
    page += "<button onclick='setMode(\"EDF\")'>EDF</button>";

    page += R"(
    <script>
    async function setMode(m){
        await fetch('/setScheduler?mode='+m);
        location.reload();
    }
    </script>
    )";

    page += "</body></html>";
    return page;
}

// Rotas
void handleRoot() { server.send(200, "text/html", htmlPage()); }
void handleSetScheduler() {
    if (server.hasArg("mode")) {
        String mode = server.arg("mode");
        setScheduler(mode);
        server.send(200, "text/plain", "ok");
        return;
    }
    server.send(400, "text/plain", "erro");
}

// ========================================================
// SETUP
// ========================================================
void setup() {
    Serial.begin(115200);
    setupPWM();

    WiFi.mode(WIFI_AP);
    WiFi.softAP(ssid, password);

    mtxSheduler = xSemaphoreCreateMutex();
    mtxLoad     = xSemaphoreCreateMutex();
    mtxTasks    = xSemaphoreCreateMutex();

    server.on("/", handleRoot);
    server.on("/setScheduler", handleSetScheduler);
    server.begin();

    lcd.begin(16, 2);
    lcd.createChar(0, barra_1_linha);
    lcd.createChar(1, barra_2_linhas);
    lcd.createChar(2, barra_3_linhas);
    lcd.createChar(3, barra_4_linhas);

    // ---------- Criando as tarefas ----------
    for(int i = 0; i < NUM_TASKS; i++){
        xTaskCreate(
            tarefaPeriodica,
            tarefas[i].name,
            2048,
            &tarefas[i],
            tarefas[i].prioridade_rm,   // prioridade RM fixa
            &tarefas[i].handle
        );
    }

    Serial.println("Sistema Iniciado!");
}

// ========================================================
void loop() {
    server.handleClient();
}
